\import Chapter2.Section7
\import Equiv.Univalence
\import Function
\import HLevel
\import Equiv.Fiber
\import Equiv.Sigma
\import Equiv
\import Function.Meta
\import Homotopy.Fibration
\import Meta
\import Paths
\import Paths.Meta

\class _definitions_2_9 {X Y : \Type}  {
  \func contr (a : X) : Contr (\Sigma (x : X) (a = x)) => lsigma a

  \func fiber (f : X -> Y) (y : Y) => Fib f y
}

\record Equiv' {X Y : \Type} (f : X -> Y) {
  | contr (y : Y) : Contr (Fib f y)

  \func toEquiv : QEquiv f => contrFibers=>Equiv contr

  \func f-1 (y : Y) : X => \let fib : Contr => contr y \in fib.center.1

  \func finv (y : Y) : f (f-1 y) = y => \let fib : Contr (Fib f y) => contr y \in fib.center.2

  \func invf (x : X) : f-1 (f x) = x =>
    \let | y : Y => f x
         | fib : Contr (Fib f y) => contr y
         | p => fib.contraction (x, idp)
    \in pmap __.1 p
} \where {
  \lemma inverse' (e : Equiv') : Equiv' e.f-1 => fromEquiv $ symQEquiv e.toEquiv

  \lemma inverse'' (e : Equiv') : Equiv' e.f-1 \cowith
    | contr (x : e.X) : Contr (Fib e.f-1 x) =>
    \let | y0 => f x
         | px0 : e.f-1 y0 = x => invf x
         | fib0 : Fib e.f-1 x => (y0, px0)
    \in \new Contr (Fib e.f-1 x) {
      | center => fib0
      | contraction ((y', px') \as fib') =>
        \let | py : y0 = y' => pmap f (inv px') *> finv y'
             | qfib : DepPath py px0 px' =>  helper e px'
        \in DepPath.apap px0 px' {Fib e.f-1 x} (__, __) py qfib
    } \where {
    \func helper  (e : Equiv') {x : e.X} {y : e.Y} (p : f-1 y = x) : HelperT p =>
      transport HelperT (inv_inv p) $ helper' $ inv p
      \where {
        \func HelperT (p' : f-1 y = x) => DepPath (pmap f (inv p) *> finv y) (invf x) p'

        \func helper'  (px' : x = f-1 y) : DepPath (pmap f px' *> finv y) (invf x) (inv px') \elim px'
          | idp => rewrite (idp_*> (finv y)) $ helper''

        \func helper'' : DepPath {Y} {f (f-1 y)} {y}
            {\lam y' => f-1 y' = f-1 y}
            (finv y) (invf (f-1 y)) idp => {?}
      }
  }

  \lemma inverse (e : Equiv') : Equiv' e.f-1 \cowith
    | contr (x : e.X) : Contr (Fib e.f-1 x) =>
    \let | y => f x
         | contr-y : Contr (Fib f y) => e.contr y
         | ((cx, py) \as center-y): Fib f y => contr-y.center
         | fib : Fib e.f-1 x => (f cx, pmap f-1 py *> invf x)
    \in \new Contr (Fib e.f-1 x) {
      | center => fib
      | contraction ((y', px') \as fib') =>
        Fib.ext f-1 x fib fib' (py *> pmap f (inv px') *> finv y') $ {?}
    }
}

\func fromEquiv (q : Equiv): Equiv' q.f \cowith
  | contr => Equiv=>contrFibers q

\func \infixl 5 ~= (X Y : \Type) => Equiv' {X} {Y}

\func contractAway {X : \Type} (a : X) (B : \Pi (x : X) -> (a = x) -> \Type)
                   (x : X) (p : a = x) (b : B x p):  B a idp \elim p
  | idp => b \where {
  \func st => \Sigma (x : X) (p : a = x) (B x p)

  \func sigma-f : st -> B a idp => \lam (x, p, b) => contractAway a B x p b

  \lemma equiv : Equiv' sigma-f => fromEquiv $
  \new QEquiv sigma-f {
    | ret b => (a, idp, b)
    | ret_f (x, p, b) => equiv-ret-f x p b
    | f_sec y => idp
  }
    \where {
      \func equiv-ret-f (x : X) (p : a = x) (b : B x p) : (a, idp, sigma-f (x, p, b)) = {st} (x, p, b) \elim p
        | idp => idp
    }
}

\lemma corContractAway {X : \Type} (a : X) (B : X -> \Type): Equiv' (contractAway.sigma-f a (\lam x _ => B x)) =>
  contractAway.equiv a _

\func exercise_12' {X Y : \Type} (e : X ~= Y) (B : X -> \Type) :  (\Sigma (x : X) (B x)) ~= (\Sigma (y : Y) (B (e.f-1 y))) =>
  {?}
--  fromEquiv $ =-to-Equiv $ pmap (\lam x => {?}

\func exercise_12 {X Y : \Type} (e : X ~= Y) (B : X -> \Type) =>
  fromEquiv $
  \new QEquiv {\Sigma (x : X) (B x)} {\Sigma (y : Y) (B (e.f-1 y))} {
    | f (x, b) => (e.f x, transport B (inv (e.invf x)) b)
    | ret (y, b) => (e.f-1 y, transport (\lam y => B (e.f-1 y)) idp b)
    | ret_f (x, b) => {?}
    | f_sec => {?}
  }



